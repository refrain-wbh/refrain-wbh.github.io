<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022年保研总结</title>
    <link href="/2022/09/30/2022%E5%B9%B4%E4%BF%9D%E7%A0%94%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/30/2022%E5%B9%B4%E4%BF%9D%E7%A0%94%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这篇博客是928刚刚结束写的，一半是因为经历确实非常曲折，不想收获的经验白白浪费，后来的学弟学妹重蹈覆辙；另外一半则是对这段人生经历的感慨，记录下来也许以后会有更深刻的理解，又或者仅仅只是为了遗忘，遗忘这段时光。</p><h1 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h1><h3 id="绩点"><a href="#绩点" class="headerlink" title="绩点"></a>绩点</h3><p>夏令营的绩点排名是10&#x2F;116（8.7%），预推免的绩点排名是6&#x2F;120（5%）</p><p>极限卡5%，还是有点意外的，因为我在大三刚开始的时候就是10&#x2F;116，努力了一个学期满绩，结果大三下还是10&#x2F;116，难绷。满绩只不过保持排名罢了，何况我后面一个同学修的学分比我多，也满绩，结果他的绩点在大三结束的时候比我少0.0001，对没看错就是少小数点后四位。有点离谱，然后大三下学期呢以课设居多，考试还能摆烂了，课设我是真的没法摆烂，所以最后一个学期的话除了一个系统结构太难摆烂拿良之外，其他的都是优（呜呜呜，大学四年终于体育拿优了），结果没想到大家比我还摆，所以我就到第六名了，这为我预推免打下了坚实的基础，说实话我两个最重要的offer都是预推免拿的。所以坚持到底也许真的有奇迹吧。</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>然后做过的项目的话，全部都是课程项目，分别是：</p><ul><li>zjq的软工（在线协作编程系统）这个项目很重要！不过可能和我担任队长有关。当时我们软工组小组，因为我在图形学也组过一次队伍叫组队战神龙，zyf和lyf原班人马加入软工（我们的软工小组名字是bighard）。zjq软工会先让大家当甲方出需求说明书，然后变换角色当乙方实现需求，当时我们小组搁那讨论了半天，然后我灵光乍现想到了一个绝妙（不是）的坑爹项目，就是现在神经网络啥的不是各种层堆叠么，我就想能不能像process on一样图形化地搭建一个网络流程图，然后自动生成神经网络代码，这样的话就能够很方便地进行调参之类的，写代码还是容易出bug。这个项目被群友起初称为第一难的项目，结果没想到还有个小组更离谱，出了一个在线协作编程系统，就是把石墨文档+vscode+github缝起来，简单来说就是能够创建工程，然后实时同步写代码，还支持github（难绷），后来老师说github不算核心需求，看看能不能砍掉。这个项目随即被评为第一难的项目，我们屈居第二。结果没想到害人终害己（不是），我们组正好抽到这个第一难的项目，而我的室友武校长抽到了我们组出的项目2333。然后我们就一往无前冲刺了，最后项目效果还是很好的，zjq评价很高，叶晨老师还把我们的展示视频二创发朋友圈了，我们自认为写的不满意，但是大家好像评价不错。就给我很大的信心！因为这个项目算是我唯一一个可以正式上线的项目。然后无论是保研面试还是实习面试都会问，主要问两块，第一块是协同编辑怎么实现的，第二块就是软工怎么开发的（这个就是敏捷开发！反正照着敏捷开发的教条一通吹就行，我们也差不多执行了？敏捷挺敏捷的，开发地怎么样就不好说了），还有问软工的一些基础知识啥的，比如黑盒白盒之类的，上课也没听过，就大概了解一点吧，细的就不知道了。</li><li>zjq的图形学（静态场景渲染），这个项目初期还用了一下写到简历了，唯一被问过一次的是北航，结果把我挂了2333。但是后期完全抛弃掉了，因为我对图形学还是没啥兴趣。</li><li>sj的计网（网络同步盘）这个项目贼TM重要！！！！建议选沈坚，痛苦一学期，面试就有的说了。这个项目几乎每次面试都会问吧，实习或者保研，问的基本上就是怎么实现的呀，还有那个什么并发编程，我这个是用epoll进行IO多路复用实现的并发，实际上还可以搞多线程，但是我是大二下学期选的sj，所以那个时候我连线程是啥都不知道，还记得问ljl和bygg全局变量能不能被线程修改2333，现在想想那时候对线程认识太浅了。但是这个IO多路复用贼重要，因为一般的问题是epoll，select的底层实现原理，这个算是经典八股文吧，计算机网络没有不问这个的。比如大名鼎鼎的redis就是用epoll实现的，epoll真的超强。不过虽然是八股文，其实可以往低下深挖很多，比如底层实现的数据结构（红黑树，用双向链表实现事件通知列表，不需要从内核拷贝事件通知列表，而是用共享内存的方式减少内核态和用户态的交互提高效率。总之虽然是八股文，但是多问几个为啥，就能挖到很深很深的地方了）</li><li>dr的操作系统（unixv6++操作系统改进，添加日志层）这个又是一个我觉得写的一般但是大家都觉得不错我也觉得有点信心的东西了，这个说实话整个过程问的挺少的，因为很少有人懂操作系统，大部分人可能也就懂计网那套赚钱的东西，操作系统能用就行。但改进这个还是花了不少精力的，也非常感谢dr老师的细心指导和引领，最后我绕过了一个我没查出来的bug，走向了光明！我应该是最早一批搞完这个的，后面有很多人问我实现思路，一开始还没啥信心，但是他们听了都说好，我就也勉强相信这个好了。这个项目记忆中就被问过两次，第一次老师根本不懂我在做啥，第二次老师还是很懂的，我这个系统没做测试，也被老师批评了，但好在其他问题我答地还好，最后老师还是接受我了，因为他觉得我综合的系统结构水平不错（实际上我觉得我系统结构水平一般）。</li><li>系统结构（单发射五段流水线CPU）这个东西全程几乎没被问过吧，可能我没有遇到过懂这个的老师？实习面试的时候公司员工更是寥寥无几（毕竟谁吃饱了撑着研究硬件呢2333），<strong>但是我觉得这个东西非常有必要写到简历上</strong>！！！如果没有更好的东西写的话，我曾经和南大的一个老师（李武军老师，他特别厉害，人也很好，以前lamda的，今年在CS招生）聊过，因为联系地晚了，他其实南大结果出来之后两天就招满了，但为啥还是愿意跟我聊呢，他说看到我成绩不错，打过竞赛，又写过编译器CPU，觉得我系统结构底子很好，他那边今年有个博士写出了一个AI编译器，然后说我可以挂名别的老师，然后去做这方面的事情。即使抛开这件事情不谈吧，我认为编译器、CPU、操作系统等等是计算机科学与技术专业的科班学生的基本功，老师就算不知道这些的实现，但也一定知道这些东西是很有价值的项目。所以写上很装b（不是）。我在知乎上面看过说，有个人去面试然后当场手画CPU的结构图，然后被当场录用了。所以大家可以好好写CPU，但是不要跟着课程写，课程写可能有些事倍功半吧，许多同学其实最后不得不借鉴一下学长学姐的？在这里隆重推荐一下《CPU设计实战》龙芯杯指定教材，作者是陈云霁，这本书贼好，作者也贼强，计算所的，保研可以保到他那里去，今年我看预推免的时候他还有名额2333，也许被鸽了吧。这本书叶神也极为推荐，所以照着这本书写真的降维打击我校课程了。</li><li>编译原理（tiny c编译器）这个和上面的一样，就是属于懂得人很少，但是大家都知道的东西。这个也不建议自己xjb写，因为这个东西太成熟了，网上有非常多的例子、教程。还有龙书呢，照着龙书写也很不错，但是难度可能有点大。github上面有个chibicc，这个项目很好，就属于那种敏捷开发的流程吧，但是循序渐进，一次增加几十行代码，你很容易地能理解一个编译器如何被开发出来的，最后开发出来符合C11标准的编译器，主要看git 的log历史，还是非常详细的。当时也是异想天开吧，这个编译器大三上的时候其实写了不少了，写到了语义分析和中间代码生成了，但是当时xjb写，就是那种，一开始想的很好，后来发现越来越麻烦的那种。然后我一怒之下就大三下学期的时候推倒重写了。我室友当时也想重写来着，可能没有足够的理由说服他，所以也还是拖到最后写的。</li><li>中文信息处理，参加了一个kaggle比赛，NLP方向，短语匹配任务，成绩不咋样，老师主要看你怎么做这个任务，顺便考察一下你的NLP方面知识，比如bert的一些结构呀，deberta做了啥优化（我们这个项目用了），还有注意力机制的一些细节，比如为啥要除以平方d之类的。反正也是问你原理，看你只是用还是自己理解了。然后对于这个任务本身考察也非常多，我被怼的贼惨2333（南大hsj老师，就追着问为什么要用这个方法，为什么这样就能计算相似度之类的）我感觉这些问题可能有些做科研的同学都答不出来，我当然摆烂说不会，最后理所当然地进了候补。不过老师让我回去认真想想这些问题，然后我想了一些，还是有些收获的，最后老师也对短语匹配提出了一些自己的看法，还是很有收获的。最后也补录到了，但最后还是没能去，黄老师没有任何问题，属于极品导师了，但是我还是觉得南大专硕很难受，没宿舍住在校外，看起来就跟局外人一样，区别对待吧。反正觉得人下人，也就是因为这个原因，我最后冲了预推免，南大如果给学硕也许我真的不会再冲了。</li></ul><h3 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h3><p>项目大概就是上面这些，竞赛方面的话，有ys和lhl大佬的带飞，拿了CCPC银牌（在此非常感谢两位大佬），ACM竞赛含金量贼高，但是全程没有老师问，因为没啥好问的可能，但是老师不问不代表没有含金量，这个东西属于老师对你的简历的第一印象，也是对你的评价的第一印象，先入为主吧。</p><h3 id="失败的科研以及感触"><a href="#失败的科研以及感触" class="headerlink" title="失败的科研以及感触"></a>失败的科研以及感触</h3><p>我的简历差不多也就是上面这些东西了。三项吧，成绩、竞赛、项目。没有科研，科研其实我搞过一段时间，但是因为那边老师压力挺大的，后来感觉撑不住跑路了，当时对我的自信心造成了毁灭性的打击，心情极其压抑和沮丧，不过这和我当时的状态很相关吧，疫情封在宿舍，然后几乎没有和人交流的机会（我的室友都在狂学！一个准备考研或者出国（大概，他平时就沉默寡言），一个和我一样准备保研，一个准备出国，所以这种氛围真的让人容易emo，然后我长期以来也非常焦虑，我感觉是焦虑症吧，就是无缘无故地开始焦虑。所以又不会自己调节，最后崩掉也很正常。）后来就去报名学校的心理咨询？但可能那边人觉得我只是单纯地学习焦虑罢了，然后派了一位讲师，聊了很久，最后收获不大。</p><p>为啥要说这一段经历呢，我想说的是，可能还有很多人和我一样容易焦虑，没有很坚定的自己的主见，环境在做啥自己就也想去试试，看到别人去准备科研自己就很焦虑，生怕错过了什么机会等等，但是呢又对自己没有足够的勇气和信心，担心自己做不好，又觉得不敢尝试，或者尝试的过程也很焦虑和恐惧自己做不好，我现在只想说，不要太看重你当下的那一天，我有个朋友曾经跟我说过，你的未来怎么样是由你的过去全部历史造就的，不是一天两天的努力可以改变的。</p><p>从我过去的经历来看，我从年初的时候就开始焦虑保研，寒假的时候练习英语的时候就很焦虑，想快点看到成果，觉得时间不够。结果后来上学忙起来了，英语就全丢掉了，最后英语也没有练好，如果我不那么焦虑，每天练个半小时，坚持上三四个月，我觉得我英语口语也吊锤夏令营了。不过问题是，夏令营的时候大家英语普遍不好，虽然我没练，最后也很焦虑，只能临阵磨枪，准备了一系列的英语问题，然后准备中文回答谷歌翻译再自己修改修改，结果我夏令营和预推免的英语问题基本上全部押中了（我感觉自己还挺厉害的hh）所以甚至当时焦虑自己英语不好也是没有必要的。年初的时候觉得自己保外无望，害怕wzh老师的名额被抢光了，或者wzh老师不认可我，然后很早就联系了卫老师，结果还是报了一系列的夏令营和预推免，最后收到了很多offer。在准备夏令营海投的时候，投稍微好点的就觉得自己不太可能入营，然后就很悲观沮丧，例如南大的lamda，清北等等，其实投了又能怎么样？万一入营了呢hh，去看那可能成功的一面，我们倾向于冒险，看失败的一面，我们倾向于保守。所以眼里盯着希望，会让自己有动力去冲，比如港中文，我都没敢报名，觉得自己英语不好，结果我室友比我英语还烂，也报名了，还通过了面试，我当时就觉得贼后悔，还有港科，有个实习，招30人吧，tm面向全球招生，我也觉得没希望，然后我有两个同学进了。港校有一些英语水平要求吧，但是不是报名的时候要求，入学之前达到就够了，但这方面我不太了解，大家想了解的可以问问jxjj？她现在在港中文，导师贼强。</p><p>许多东西去尝试了会有意想不到的结果，在尝试的时候不要太过关注于失败，眼睛里盯着那些成功的地方，会让自己有激情和动力。或者换个视角，将尝试看做是自我超越的机会。面对困难和可能遭受的失败，难受是肯定的，但不要逃避，冲过去了就光明了，就算失败也能坦然了，但是逃避之后而遭受失败，只会打击自己的信心。实际上如果对自己的内心做认真的审视，也许我们能够发现，最让我们害怕的东西不是失败，而是失败的可能性。当失败实际上已经发生的时候，我们很快就能接受，但当失败可能发生的时候，我们就会无比害怕，以至于让自己的行动受阻。而这种失败的可能性，就其可能性来说，不如说是一种偏见，对于自己的处境的一种无明的偏见，我们对未来总有这样那样的预期，但是未来并不总是按照我们的预期那样走，事情是客观发生的，不被人的主观意志所转移的，大概意思就是这样。为啥不能对自己的未来有着好的方向的偏见呢？这种偏见是长久以来形成的思维模式，改掉很难，但是可以通过自我觉察，去觉察自己的思维模式，让自己能够不被自己所幻想出来的东西束缚手脚。</p><h3 id="夏令营-x2F-预推免参加情况"><a href="#夏令营-x2F-预推免参加情况" class="headerlink" title="夏令营&#x2F;预推免参加情况"></a>夏令营&#x2F;预推免参加情况</h3><p>夏令营：</p><ul><li>北京大学软件与微电子学院 初筛未通过（正常，但听说今年鸽穿？）</li><li>北京大学深圳研究院初筛未通过（需要联系导师我没联系，本来也对深圳没好感，只是lyx同学报名了，我觉得试试也无妨）</li><li>清华大学深圳研究院初筛未通过（报了北深怎么能不报清深？）</li><li>复旦大学大数据学院学硕初筛通过，面试挂（贼惨的挂的那种）</li><li>上海交通大学计算机学院初筛未通过（正常，但是听说今年鸽穿？）</li><li>浙江大学计算机学院直博有机会参加夏令营，放弃</li><li>南京大学计算机学院面试通过，最后只拿到专硕名额</li><li>南京大学lamda初筛未通过（可能报的老师很火吧，又或者太有名很多人报名）</li><li>南京大学人工智能学院今年似乎计算机学院&#x2F;人工智能学院二选一，报了一个就不能报另一个</li><li>中科大信息安全学院面试通过，学硕</li><li>中国人民大学信息学院面试通过，学硕</li><li>中国人民大学高瓴学院学硕初筛未通过，但最后还是毫无疑问地鸽穿</li><li>自动化所初筛未通过</li><li>计算所初筛通过，未参加后续（因为不太想去计算所）</li><li>软件所初筛通过，未参加后续</li><li>北京航空航天大学学硕初筛通过，面试未通过进wl（真的有点意外，因为我觉得他和我校差不多，最后928鸽穿打电话给我，我当然很高兴地拒了）</li></ul><p>浙大需要联系导师，我联系了，暑期要做两个月的项目，最后导师要你就行，但是我没有什么直博的意愿，最后还是没参加。还是跟着lyx同学的风 投的，我只能说不要怕错过什么机会，当时拒了还是很难受的，以为自己又少了什么机会，因为对自己没有什么信心，但是后来回想起来，我想说这个直博*都不去。两个月时间非常久，而且不是百分之百录取，甚至只是50%或者更低，但是浙本爷就是百分之百录取，而且还占名额。浙大本校保护贼严重，听说浙大网安今年已经录取了的外校的学生，结果临时有三个浙本爷要读硕士，结果把后三名直接取消录取了，有两个人被逼直博，还有一个武大的学生因为有本校保底，所以不怕，跟着浙大教务硬刚。我觉得挺恶心人的，浙大高中还是梦校，这一通操作让我觉得浙大也就那样。另外浙大留给外校的硕士也寥寥无几，绝大多数浙本爷内定。上大学之后我去浙大看过一次，不记得去的哪个校区了，但是一进去一大片超大的空地，毫无美感，总让我有一种铺张浪费的感觉。</p><p>夏令营看起来报了很多，但大部分还是入不了营的，因为大佬太多，然后基本上都是海投，所以大部分offer集中在少数人手上了。点评是：赢家通吃，败者食尘。要么自己足够强，要么就得走一些不那么容易走的路，比如错峰报名（复旦大数据，科大网安），提前联系导师进组打工（清北日常），还有直博，最后一个当然是预推免捡漏啦hh，不要以为预推免捡的都是大佬不要的offer，你想想为啥他们当初为啥拿offer，没点含金量会拿么？鸽子满天飞的时候，你会发现从前高高在上的名校求着学生来，被放鸽子的也基本上是强导。某同学928拒了本校，直接上岸浙大。另外预推免也不能完全是捡漏，因为有很多学校大部分名额会留给预推免，比如清软今年只在预推免招生，北深夏令营只是搞个导师见面会，还有复旦是把大多数名额留在了预推免，浙大硕士只在预推免招生，还有南大也在预推免招了一半的学生。</p><p>预推免：</p><ul><li>北大计算机学院面试通过，学硕</li><li>北大智能学院压ddl报名，结果错过了2333</li><li>清华大学深圳研究院初审未通过</li><li>清华大学软件学院初审通过，面试未通过</li><li>复旦大学计算机学院面试通过，学硕，最终去向</li><li>浙江大学计算机学院初审未通过</li></ul><p>预推免就简单多了，反正夏令营有南大了，报名当然往上面报名，所以也就参加了清软，北大计算机和复旦计算机。最后出乎意料地拿到了后面两个offer，我真的不敢相信。反正在保研结束之前，谁也不知道自己最终会去那儿吧，反正一直往前走就对了。在9月22号早上之前我还觉得没啥希望，也就参加一下不留遗憾，已经做好了去南大的准备，结果9月22号上午面试完中午收到北大老师的电话，然后第二天，9月23号复旦上午面试完中午收到了复旦老师的电话。所以事情好像在最幽暗，希望快要熄灭的时候，突然峰回路转，眼前一片光明。这个经历也是促使我写下这个博客的一个重要原因，倒也不是用来佐证坚持到底就是胜利，这话也只能说给最后胜利的人听，我只感觉很幸运，但那刹那间又觉得很虚无，认真做的事情反而失败地彻底，随便做的事情反而无比顺利。至少，不应该放弃希望，准确来说，要去拥抱自己的未来的种种可能性，要勇敢地去存在。</p><h1 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h1><h3 id="复旦大学大数据学院"><a href="#复旦大学大数据学院" class="headerlink" title="复旦大学大数据学院"></a>复旦大学大数据学院</h3><p>按照时间顺序依次讲保研经历吧，我参加的第一个就是这个学院，说实话挺意外的，因为我排名第10，基本上是不可能进复旦大学的，比如，今年复旦计算机学院在我系CS夏令营，入营只要了前六名，基本上就是5%的线，所以我是没有机会入营的。这就是打信息战了，虽然我最后面试没通过，但是这个决策是一点问题都没有的，甚至引发了一系列的链式反应，我参加的第一个夏令营是复旦，收到的最后一个offer也是复旦。兜兜转转走回起点了吧，黑格尔从纯存在出发最后矛盾运动的最终结果就是存在本身，这样的一个圆圈还是让我很有感慨和激动的。</p><p>为什么我会选择报这个学院，最重要的因素就是计算机学院往年基本上进不了夏令营，所以其实希望不大，但是呢，我一开始就在关注大数据学院，并且详细了解了这个学院，而不是计算机学院，所以我在报名的时候其实倾向于大数据学院，所以不会去计算机学院当炮灰。因为大数据学院真的非常好，不亚于计算机学院，只是不出名而已。当时在我前面的和在我后面的基本上都报的是计算机学院，所以理所当然地被拒了。我当时收到大数据学院的入营通知的激动还是让我非常印象深刻的。</p><p>大数据学院非常地nice，大家可以去知乎上搜   <a href="https://www.zhihu.com/question/455672985">https://www.zhihu.com/question/455672985</a>   ，那里面列出来的导师都不错，尤其是魏忠钰老师，好评如潮，是复旦NLP组的成员，他们实验室有位许嘉蓉研究员，特别好看，嗯，大家可以搜一下 <a href="http://www.fudan-disc.com/people">http://www.fudan-disc.com/people</a> 。大数据学院当时我报的学硕，专硕太tm贵了。学硕发的是统计学毕业证，不过没有关系，这个学院有至少一半的老师在做AI，包括CV NLP 机器学习等等，</p><p>至于面试就贼惨，哎，我当初希望的是能够一战直接上岸复旦大学，不用受后面长久的折磨，结果没想到一直延续了三个月。复试通知是6.26发的，面试应该是7.4还是7.5。这中间我一直在准备，但是面试一塌糊涂。</p><p>后来理所当然地g了，据说在候补中游，然后最后补到了，但是因为预推免报名了计算机学院，复旦系统会自动取消其他学院的候补。但这不是最恶心人的，最恶心人的是大数据学院在我准备面试计算机学院的那天早上打电话告诉我候补到了，然后还告诉我我放弃了候补，所以这个名额给别人。真的很难绷，搞得我当时就不想准备计算机的面试了。但好在中午的时候收到了计算机的offer。</p><p>因为这是第一次夏令营，而且还是我最喜欢的学校，却挂地彻底。因为我满怀期待地准备挺久的，结果一个问题都没答上来，真的心态崩了，但崩完之后也就不再抱有那么大的希望了吧。不过我想说：</p><p>我好不容易心动一次，你却让我输的这么彻底，哈哈哈哈…… 焯！</p><h3 id="北航计算机学院"><a href="#北航计算机学院" class="headerlink" title="北航计算机学院"></a>北航计算机学院</h3><p>这天算是极限ddl吧，记不得哪天了，反正是一天面试三场，分别是北航，同济和人大。北航的话会有个摸底的机试，基本上是大模拟，不涉及算法。然后是面试，面试还是挺丰富多彩的，照着简历问吧，首先是英语，然后是一些数学知识，问的挺有意思的，就是那种，对某某的理解。最后就是计算机知识和一些简历上的项目了。大概20分钟？我感觉我答地也妹有问题啊，最后还是挂了，在wl的中游。这个也有点搞我心态，因为北航我以为和我校差不多档次。不过我也大概率不会去的。</p><p>听人说有人被北航压力面，面地怀疑人生，但是我的面试老师挺好的，没有追着问。感觉还是体验不错的。</p><h3 id="同济大学电信学院"><a href="#同济大学电信学院" class="headerlink" title="同济大学电信学院"></a>同济大学电信学院</h3><p>当一回本校爷！考试规则极其复杂（一看就是sj风格的），上机测试的软件非常难用，过程还全程打开腾讯会议音频，隔三差五就有人直接开麦说老师我触发作弊警告了（实际上随便搞一下都会触发）真的有些难绷。那个界面写得也令人不敢恭维，有的文字大，有的文字小。还有那个录屏软件也不知道谁写的，把系统资源都耗干了，最后电脑一卡一卡的。笔试感觉写得不咋地，但是最后成绩还不错，夏令营的第三名。这点同济还是公开透明的，考了多少分就是多少分，全部公示出来。某华五学校完全黑箱操作，让我很难受。</p><p>欢迎大家报考同济！同济虽然面试体验一般，但是通过面试的概率非常大，一般进了夏令营就比较稳了，复旦进了夏令营才刚刚开始，因为10%录取。</p><h3 id="中国人民大学信息学院"><a href="#中国人民大学信息学院" class="headerlink" title="中国人民大学信息学院"></a>中国人民大学信息学院</h3><p>哎，算是很想去的学校了吧。要是高瓴我就绝对去了，当时这个学院报名截止最早，5月20号。几乎所有人都会把他当练手吧，就是准备材料之类的，准备这一个学校的材料，后面的复用很多。研究半天报了一个什么大数据科学与技术方向学硕，当时联系了金琴老师，老师表示很欢迎，然后建议我填这个方向。结果，tm这个方向有100多人入营！招生也就找10来人，有的方向，大概招录比也就1：1。反正出结果的时候觉得自己被坑了。</p><p>面试过程及其曲折，当时我刚参加完同济的面试，正准备登录腾讯会议，发现有人给我打电话，一问原来人大信息学院打电话过来跟我说已经轮到我了，我不在，所以跳了过去，然后让我放心，放在稍后面试。但是很难蹦的是，今年突然给了一篇英文论文，给15分钟左右阅读，然后面试的时候英语讲，我绷不住了，也妹听说有这个环节啊，可能是人太多用来筛选的，但是我英语真的不太行，硬着头皮看。然后突然我家里人到我房间，跟我说有人找我，一听才发现，在我身后的第二机位设置了静音，我登录错了会议，人大那边始终联系不上我，只能打电话给紧急联系人。而且打了两次电话，我爸以为是推广电话，就直接挂掉了，第三次才接。真的，人大的老师真的太负责了，换成别人可能就把我取消资格了。然后登录正确的会议，重新发了一篇论文，又硬着头皮看，实在看不明白，心想这回凉透了。但面试官很和蔼，就问了论文讲了啥，我东拼西凑了几句，老师就问别的问题了。问的问题基本上就是一些基础概念，然后就是项目了。</p><p>所以人大的老师还是不错的，很负责，让我对他印象加分了很多。最后在南大面试一结束，我收到了人大的offer。于是南大面试地一般的事情被我抛在了脑后。赶紧联系金琴老师，老师两天没回，我有些急，就找了学长拜托联系了一下，然后和金老师聊得还不错，但是我当时还有点想等南大的结果，所以也诚实和老师说了，老师也没说啥。过了两天老师就答应其他人了。这件事情让我非常难受，因为金琴老师的实验室非常好，我也联系了很多学长问过了。当时心态崩了，抑郁难受了很长时间，可以说是最大的一个挫折吧，因为我其实很想去的，但是当时临场的时候还是太天真了，有些想法不用完全说出来，因为金老师也跟我说，如果有更好的去处就尽快跟她说的。怎么说呢，有机会在眼前最好还是不要轻易放弃吧，毕竟你跟老师说不一定来，老师也就不一定要你了。好好掂量一下，老师不要你的结果你能不能承受吧。</p><p>但是还是极力推荐金琴老师，金老师已经是正教授了，但还在科研一线，亲自改学生论文，和学生打成一片，说话也非常温柔。实验室产出挺不错的，做多模态。</p><p>后来又联系了张静老师，张静老师人也很好，给我充分的时间考虑，要不要去，不过后来我收到南京大学黄书剑老师的offer，所以最后还是决定选南大。张静老师非常优秀，是唐杰老师的博士生，和唐杰老师有很多合作。另外，张静老师还亲自指导论文写作，自己也在科研一线，近年来还在一作发论文。张静老师近年转向了知识图谱，也是不错的研究方向。</p><p>人大信院有点意难平吧，这个院在CS系挺不出名的，学科评估B+好像，但是这个院属于那种小而精的，数据库方向贼厉害，据说如果导师是杜小勇老师的话，在北京面试数据库方向基本上横着走。这个院前些年还是非常强的，比如文继荣、赵鑫、卢志武等等高瓴名导原本都是这个院的，高瓴基本上就是信息学院的AI方向老师起家的。所以这个院的一些老师是非常强的，只不过总体老师很少，所以学科评估一般。还有很厉害的老师比如，系统方向的张峰（听说他的学生都是清北、上交的），范举，我觉得可以重点关注近年引进的人才。听说人品不错的老师包括柴云鹏，还有一个**才的老师，名字记不得了，最后一个字是才（听说天天实验室欢声笑语）。</p><h3 id="南大计算机"><a href="#南大计算机" class="headerlink" title="南大计算机"></a>南大计算机</h3><p>今年南大计算机和人工智能基本上就是二选一，虽然两个都能报，总体感觉的话，人工智能bar高一些，因为发的都是学硕（羡慕），计算机的话，应该按照面试排名，前多少个学硕，后多少个专硕，学硕专硕基本上1：1吧。反正南大历年大海王，先放一大堆人入营，然后来个上机筛人，最后面试。上机的题目还是非常非常考验计算机的基本功的，虽然都是选择，但是有一百多道，更有甚者，多选题多选漏选不得分。然后面试就很诡异了，听说有的老师只问项目，有的老师只问专业课。计算机问的当然是408，人工智能则问线代机器学习之类的。复习有个侧重点就行。我的老师是只问项目，但是呢老师好像也不太懂我的项目是啥意思，所以扯皮了一会，体验不太好。最后我感觉应该凉了吧，但是随即收到人大offer，也就把南大的面试抛到脑后了。</p><p>然后拿到了南大专硕，面试表现不太好，但是运气成分居多。南大专硕没有宿舍，一年学费一万，租房子一个月大概2000以下，1200以上。有个和园离南大挺近的，但是和园很大，最远的地方也有两三公里。而且比较破，比较好的宿舍很远，大概骑个电瓶车15分钟。但是我觉得南大的专硕学硕运气太多了，基本上所有学校都是学硕专硕分开的，学硕候补学硕，专硕候补专硕。这样方便了教务，但是苦了学生。为了让大家了解南大教务，可以参考知乎上面的两篇帖子。<a href="https://www.zhihu.com/question/31108740%E4%BB%A5%E5%8F%8A%EF%BC%8Chttps://www.zhihu.com/question/64271290/answer/2664739680">https://www.zhihu.com/question/31108740以及，https://www.zhihu.com/question/64271290/answer/2664739680</a></p><p>这两篇还是一些道听途说了，我自己的经历则是，南大貌似夏令营没有候补任何同学，因为有个wl5-10名的同学居然一直没有被候补，难道南大10个鸽子都没有？最后南大鸽穿了。学硕鸽了不让专硕补录，专硕鸽了不让夏令营的wl补录。夏令营的wl和预推免的wl一起按照成绩排名，但是我寻思这两拨人也不是一个时间点面试的啊，怎么一起排名？据说优先递补预推免。但是南大不公开成绩，也没有名单，所以谁也不知道咋回事。我有个20名左右的同学补录到了，但是前面那个5-10名的同学还没有补录到。至于夏令营鸽了的，应该都给了预推免。</p><p>但是，预推免的那一批应该是夏令营被初筛筛下来的，一般来说是夏令营的生源更好。我听说预推免反而容易拿学硕之后还是心理很不平衡的。那也没有必要报名南大的夏令营，直接等预推免就好。因为南大机制是，进了夏令营的同学不能报名预推免。所以那些专硕的同学想要在预推免冲击学硕是不行的。但让我心寒的是，我打电话问南大教务的时候，南大教务一直告诉我有机会补录到学硕。</p><p>后来我也因为我是专硕，然而我实验室的所有其他同学都是学硕而彻底心寒，在听说预推免反而更容易拿到学硕之后也很生气。最后决定报名预推免。</p><p>南大算是梦校了吧，我预期大概也就是南大。然后南大其实还有很多优秀老师，如果去人工智能学院不去lamda的话，不如去cs。因为人工智能学院的实验室基本上都在CS招生。例如NLP组黄书剑老师招生（很好的老师），CV组王利民老师招生，李武军之前一直在lamda实验室，今年独立招生。还有强化学习的组也在CS招生。其中王利民老师贼强，是汤晓鸥老师的博士，谷歌引用破万，而且还是青年教师，我有个同学放弃了高瓴，拿的南大专硕，还是选择了王利民老师。李武军老师则主要做分布式机器学习，其他的记不太清了，实力也非常强劲。南大的软件所非常值得报名，例如马晓星老师，蒋yy老师（这位老师改革了南大的操作系统课程）还有新引入的老师，左志强，据说是国内为数不多在某顶会上发过论文的人。总体来说，南大的计算机学院不算巨无霸，但是仍然得到了A的学科评估，计算机各个分支都有比较厉害的老师，据说南大PL国内第一。</p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p>中科大基本上就是我这个排名去的地方，但实际上随着大家越来越卷，应该不会满足于此了。我联系中科大老师挺早的，一开始联系了冯福利老师，结果冯老师一直没回我，我第一次陶瓷就失败，我当时躺在床上emo，然后就觉得自己在AI方向优势不大，不如去套系统方向的老师，于是找到了李诚老师，结果李诚老师那里没有名额了。（这里也介绍一下李诚老师，李诚老师也非常厉害，发过OSDI，这个会议非常难发，每两年举办一次，每次仅仅录用40篇左右，相比较于AI领域的论文录用，实在是太少太少。所以在这个会议上发过论文的基本上都是大牛。他主要研究的是分布式系统，似乎也在研究分布式机器学习系统）然后我就不知道该怎么办了，因为中科大计算机有四个学院，分别是，计算机学院，大数据学院，信息科技学院，以及网安学院。当时我本着正统思想报的计算机学院，然后发现计算机学院做AI方向的很少，虽然我当时一时上头想去做系统，但冷静下来还是想去做AI。过了很久，冯福利老师总算回我了，说要和我聊聊，当时已经六月末了。我应该六月中旬发的邮件。了解到他目前只在信安招生，并且如果要进组需要经过两轮考核，第一轮需要读一个星期论文，第二轮需要复现论文。当时时间很少了，夏令营马上就要开始了，我就寻思夏令营结束再去看看能不能面试了。然后碰巧我同学转给我一个中科大毛震东老师招生的信息，在网安招生，我一合计觉得网安有两个不错的老师，就申请解锁CS的志愿，然后报名网安去了。</p><p>毛老师也需要两轮考核，第一轮是选一个题目准备一个星期然后讲，第二轮是读论文。第一轮的话差不多就在6.26之后，也就是我在准备复旦的夏令营。当时其实也不太想参加，我觉得参加夏令营比较重要。但是我先了解了一下第一轮可选的题目，发现里面有一个SVM的原理和实现，我对原理性的东西非常感兴趣，所以觉得可以冲，另外这个SVM也是机器学习的重要算法，所以学了之后面试说不定用得上。所以我是基于这个原因，在繁忙的夏令营复习中抽出两天时间好好学了SVM然后做了三十多页的PPT。结果他们只要求我15-20分钟，但我要讲的内容必须30多页才能放得下，所以我就没管时间限制，直接狂讲，尽可能地讲快点压缩时间吧。反正讲的他们说一点问题都没有，最后问了两个无关痛痒的问题就结束了。</p><p>第二轮是在网安面试结束之后，给了一天时间看毛老师的一篇论文，论文还算简单，但是确实挺巧妙的，我把原理翻来覆去推导了三四遍，讲论文的时候我又把推导给详细展开讲了，时间也超了不少（但我已经尽力压缩时间了2333），然后老师挺满意的。就这样通过了毛老师组的面试。但是可惜犹豫半天还是最后还是选择了南大黄书剑老师。</p><p>在这里也重点介绍一下毛老师组吧，毛震东老师目前隶属于张勇东老师实验室，张勇东是国家杰青，所以项目这块不用愁的，不至于没有科研经费。毛老师组有三位老师，分别是毛震东老师（多模态），王泉老师（NLP，知识图谱方向）以及胡博老师（推荐系统），毛震东老师人品极好，参考研控，研控有些黑料是尬黑了。我问过毕业了的学长，他的反馈是老师人品好，但是比较忙，你有什么事情找他他都会尽力帮你解决，比如改论文，讨论idea等。王泉老师是李航老师的博士，还是很厉害的。毛震东老师和王泉老师从前是信工所，隶属于李斌老师的，李斌老师的实验室知乎上都很有名，但李斌老师后来去了小米，他们也跟着走了。组内有一些打工项目要做，但是不多，大概平均下来两周一天的样子。相应的回报很丰厚，据说组内的补助是他们认识的人当中最多的。</p><p>然后再介绍一下冯福利老师，虽然很遗憾最后没有参加他的面试，但是毫无疑问未来是大牛，2019年博士毕业于新国立蔡达成老师的实验室，谷歌引用已经3000多了。冯福利老师今年到中科大就职，清北学生闻风而动。另外一起来的是另外一位大神，王翔老师，王翔老师也是2019年毕业，和冯福利老师同门，谷歌引用6000+。他们目前应该是在何向南老师组内。有想法的可以早点陶瓷。</p><p>中科大还有很多很厉害的老师，可惜因为理工科+地处合肥，优秀的男女生比例让人难以靠近。值得一提的是，中科大超弱commit，夏令营只是走个过场，主要是导师自己的考核，这点和清北有点像。其他的华五应该硕士不存在这样的情况。中科大而且招收的全部都是硕士，没有直博，博士都是硕士转的。而且中科大转博非常容易。所以中科大可以早点陶瓷，进组打工。另外，大数据据说bar还有点高，但联系导师基本上应该没啥问题，至少网安的话，今年第一年招生，往年是和信科一起招生的，反正年年被鸽穿，今年大概也差不多吧。bar很低！而且有毛老师和冯老师和王翔老师这样的好老师在，所以冲网安也不错。另外，网安还有一些网安方向的大佬。冯老师和王老师主要搞推荐系统。</p><h1 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h1><p>预推免就比较简单了，我原本都打算放弃预推免，就去南大，然后我还找了一段时间的实习，一直在准备实习的东西。但想想还是报名了，毕竟心理还是有些不甘心。</p><p>夏令营基本上7月下旬就结束了，预推免则到9月中旬，这中间我过的还是非常痛苦，因为让我接受南大没有宿舍确实有些难。我慢慢地给自己建立心理防线，安慰自己说没有宿舍租房子一个人住也很爽，差不多也能接受吧。但是当我听说将要成为我的同学的学生也是学硕的时候，我就破防了。就是说服自己是件很痛苦的事情，也是一件扭转人性的事情。这和坦然地面对是两码事。比如谈恋爱或者结婚，和一个差不多能将就的人一起，就需要花很多时间去说服自己，这就是自己和自己的斗争。然而这过程中自己内心的真实想法就被压抑了下去，属于妥妥的精神内耗。而且更容易会发现对方的缺点，放大缺点。而和一个自己很喜欢的人在一起，她的缺点则可以被忽略。</p><p>而另外一种心态则是，能够就事情本身是那样地去接受它，或者承认它，需要承认当时我只能去南大专硕，也必须承认自己内心不满，不应该掩盖这种内在的矛盾。而是想办法去化解。要么就去南大专硕，变得更强，要么</p><h3 id="清华大学软件学院"><a href="#清华大学软件学院" class="headerlink" title="清华大学软件学院"></a>清华大学软件学院</h3><p>这个学院不太一样的地方在于，其他学校的软件学院基本上都是捞钱的地方，但是这个软件学院却不是，他的前身是另外一个正经的清华的学院，所以这个学院不算是那种纯贴金的地方。里面也有非常厉害的老师，但是网上风评不太好，参考研控。我个人觉得这个学院一方面是正统清华人，另外一方面有几个老师还是相当相当厉害的，搜一搜基本上就能知道。但是吧，应该比较厉害的都被本校爷占了。所以可能想找到很好的老师比较难，除非很早陶瓷。至于哪个老师好，目前了解到的应该是lms。挺强的。我也没想到我能入，面试过程也还好，比较顺利，我另外一个同学则被怼的很惨，但虽然如此，我最后还是没有进。这让我有些挫败，不过也能接受。</p><h3 id="北京大学计算机学院"><a href="#北京大学计算机学院" class="headerlink" title="北京大学计算机学院"></a>北京大学计算机学院</h3><p>这个我是真的没想到能入，而且还过了。当时我实在不抱希望，然后就一直拖一直拖，报名截止前才交了材料，相应地，智能学院甚至没有报上名。然后我当时可能还是觉得系统有意思，就报名了体系结构，没想到的是，北大居然每个方向限选导师，我入了才注意到。系统结构方向的老师非常少，我联系了不少都没怎么回复。大部分应该都被占了吧。我也觉得很沮丧，就随便面试了，面试早上8.50开始，我7点开始做PPT吧。有点难绷，反正也不焦虑，就是不想做，一直拖。最后面试很顺利，问的很多问题我都答出来了。后来我才知道，原来不仅仅是分方向，还分不同实验室的面试。我理解的大概是，我们先报名，然后每个实验室在指定方向里面挑学生，挑好了学生上报给教务处，教务处就说这些人入了。然后面试也是实验室面试。基本上可以说就是导师看中几个人，然后让过来面试这种。</p><p>面试结束之后，当时面试我的老师就打电话过来问我有没有意愿，我当时不知道他就是我的导师，我还犹豫了一下，多方打听才知道，原来是和导师一一绑定的。难绷，我了解了一下老师，做图计算的优化的，这个方向我不了解，但是看到优化我就很激动。我也问了学长说人品很好，年级很大了，还在科研一线，去年还发了一作论文（其他作者是同事），就是那种不是只说不做的老师，是余华山老师。不过他只招硕士。相比较而言余老师可能成果没有很突出，但是人品和科研态度没有问题。而且据说组内也不push，兴趣驱动吧。老师联系我也让我受宠若惊，但是后来因为有复旦的AI方向的offer，还是忍痛拒绝了。</p><h3 id="复旦大学计算机学院"><a href="#复旦大学计算机学院" class="headerlink" title="复旦大学计算机学院"></a>复旦大学计算机学院</h3><p>啊哈哈哈，复旦来喽（突发恶疾）。怎么说呢，还是觉得很感慨吧，第一个夏令营就是理想的复旦，然后狠狠地拒了我，我当时还查了资料，为复旦编写了一个英语问答：你为什么要选择复旦，然后英语回答把复旦两个字的历史讲了一遍。绕了一个很大很大的圈子，最后还是复归到复旦。之前提到，如果我不报名计算机，就能被大数据学院录取，所以复旦面试当天早上我也很绝望沮丧，甚至面试前两个小时才开始复习。但是结局却出乎意料地圆满，有三个当时面试我的老师联系了我，问我有没有意愿去读，其中两个是直博，一个是浦江实验室的老师，方向是CV，据说导师会是王晓刚老师（大家可以自行百度），另一个老师是NLP方向的。还有一位老师有硕士的名额。我其实一直不太想直博，但收到两位超强的老师的直博还是非常激动的，我一度想冲，但是还是忍痛拒绝了。我觉得我目前不太适合读博。另外一个老师则有多模态的方向，我觉得也还不错，所以就答应了。但晚上的时候我躺在床上后悔，觉得去NLP方向的那位老师那儿直博真的是绝佳的选择。于是第三位老师晚上再联系我的时候，我就表示可能还会再考虑考虑了。结果没有想到第二位老师大晚上9点多说有硕士要不要来，我想都不想就答应了。因为确实很想去，不然我也就不会后悔没有直博了。算是等到最好的结局了吧。感觉自己真的很幸运。</p><p>我参加北大和复旦的预推免的时候，考前我真的一丝丝信心都没有，只想摆烂，但是摆烂反而让我在面试的时候生出了一种无所畏惧的迷之自信，面试表现还是非常好的，比如回答从容坚定，不焦虑，因为我没什么好害怕的，就是单纯的没有信心所以不想复习，因为有南大，再不济去南大专硕也能接受。但最后结果出乎意料地好，面试之后两个学校的老师都打电话来问我有没有兴趣读研究生，我：？？？倒不是炫耀自己摆烂也能通过面试，而是心态平和，不要感到焦虑和恐惧，事情反而更容易成功。</p><p>于是复旦就是我最后收到的offer。收到之后，我的保研也就结束了。似乎是一个戏剧性的结尾。</p><h1 id="给学弟学妹们的建议"><a href="#给学弟学妹们的建议" class="headerlink" title="给学弟学妹们的建议"></a>给学弟学妹们的建议</h1><p>写了这么多，大概的心路历程应该明晰了，总体来说，就是非常没有自信，非常焦虑，非常纠结和挣扎，最后还是有了一个满意的结局吧。但好在我虽然没有上述的这些好的东西，但我至少报名了，尝试了，当时也许只是想阵前放三枪，也就对得起自己了。但是其实一上路之后，就自然地开始走起来了，就会自然地开始准备英语（我最头疼的），自然开始复习专业课，自然开始看项目。所以，没有被恐惧完全占据了头脑。</p><p>如果要说什么建议的话，首先就是，<strong>要搞清楚自己到底想做什么</strong>，可以看到我整个过程不断在AI和系统结构之间摇摆，我感觉我都有兴趣，但是却不能决定，因为感觉两个方面我都没有足够坚实的基础。搞清楚自己要做什么不意味着你要站在旁边观望，看看哪个方向好。不是这样的过程，如果我不上手去做，不去学知识，不去做项目，那么我永远觉得两个方向都好，但也都有缺点。我没有和这些方向建立足够亲密的连接。什么叫学而时习之，不亦乐乎。这里的习大概就是熟悉、习惯的意思。大概就是，我感觉哪个方向可能有意思，那就去往这个方向走，走足够多的路（不能浅尝辄止）再判断这个方向适不适合自己，大概率还是会适合自己的，因为我一开始对那个方向就有所领会，觉得会有意思，其实哪个方向也许都有意思，只是需要深入钻研。</p><p>这样和某个方向建立足够多的连接，我就觉得这个方向很熟悉，很亲切，那么我就会自然而然地不断投入更多精力，学到更多的东西，在我保研找导师的时候我自然会去找这个方向的导师，也就不会盲目和纠结了。</p><p>这几个月下来，我翻来覆去想，可能还是要做一些自己感兴趣的事情，才能活的不那么无聊吧。生活可以很快乐，可以很舒适，但是却仍然无法避免无聊。</p><p>这是首要的，和重中之重的，就是方向问题，即使以后的想法就是去工作搞开发，那我觉得研究生也是很有价值的。我更倾向于认为学习知识的知识本身并不重要，而是要学习到那种学习能力。有了科研的这段精力，我觉得学任何东西我都不会害怕了。所以抱着一种尝试的态度去对待科研或许是比较好的。直接工作未尝不是一件坏事，可惜的是大家现在都流行读研，可能很多人也是被裹挟着读研吧，至少我有这样的感觉。</p><p>有了方向之后就可以联系导师，然后进组打工，建议联系清北。清北绝对的弱commit，反正一波操作下来，就算没有被清北录取，那有了这段科研经历，在保研的时候也还是非常有优势的。</p><p>就算不是提前进组，联系导师也很有必要，因为很多好的老师名额紧张，往往会设置非常多的考验，早点联系早点通过考验，不然到夏令营的时候真的没有时间准备老师的考核。另外联系导师的作用比你想象中的作用大地多得多，这个是北大的一个老师跟我说的。</p><p>另外一方面，换位思考一下，如果自己是导师，是更愿意招收一个自己熟悉，知根知底的学生呢，还是一个陌生的但是看起来很强的学生呢？老师也是人，人总是会更相信关系近的人。</p><p>联系导师也不要太当回事，因为老师一开始也没把你当回事，一开始谁都不认识谁。所以联系了一个老师没有回复，或者回复消极，不要气馁，因为原因太多了，可能老师根本没看邮箱，又或者老师本来就喜欢本校的学生等等。一定要早发邮件，多发邮件，把联系导师的心理障碍去掉。另外也是打磨一下自己的自我介绍之类的。还有就是，联系导师一定要从最喜欢的开始联系，最喜欢的也许很厉害未必收你，这时候很可能就气馁，觉得自己可能没那么优秀，老师看不上。但是不试试谁知道呢，老师不仅仅只看你的一些数据，老师的印象有很多来源，包括本科学校、你的自我介绍语气、你对他的研究方向的了解等等。一般来说，老师会非常喜欢对自己方向很了解的学生，这种学生一般能做好研究。一定要从最喜欢的，也就是从高往低套，不要怕被大牛拒绝或者嘲讽啥的，绝大多数老师还是对学生有着基本的尊重的。而且多套几次，拒绝多了，<strong>也就麻了</strong>。那种麻痹的感觉真的很好，就很上头，变成彻底的赌徒，开始疯狂联系自己最喜欢的老师，而不再担心被拒绝了，万一接受了呢？那不是赚大了。这个和谈恋爱是一个意思，被拒绝第一次：很伤心，第二次：很绝望，第三次：我好不容易心动一次，你却….，然后就变成渣男了。我有个学长想直博，给三十多个老师发邮件，回复的寥寥无几，但就是那寥寥无几的几个人让他上岸了上交。</p><p>然后就是一些简历上面下功夫准备了，首先绩点肯定要稳住，别没有保研资格了，而且绩点太低入营说实话很困难，因为报名人太多了，为了减少工作量，首先把排名低的筛掉是很正常的，一个很简单的分布问题，优秀的学生在高分数段更密集，在低分数段更稀疏。这类能力很强但是成绩一般的尽可能找弱commmit会更合适。但是你校有个好处在于，竞赛和科研加分贼多，搞个国二以上，基本上就能进前15。预推免用这个排名上岸也不错。</p><p>然后竞赛的话，含金量最高的可能就是ACM了，这是硬通货，还有些比赛就是属于那种比较专业性的，比如龙芯杯，体系结构方向绝对是含金量贼高的。再比如KDD Cup，人工智能方向的也是非常好的比赛。</p><p>科研和联系导师关系比较大，可以找本校先打好基础，然后联系想去的老师那里做科研。</p><p>项目的话，可能需要投其所好，就是和老师研究方向契合。如果是夏令营和预推免面试的话，那么可能需要准备一些大部分老师能问得出来问题的项目，比如软件工程，搞个在线协作编程系统啥的。放上编译器CPU，可以凸显你扎实的基本功。还有一些方向性的项目，比如图形学方向的项目，还有NLPCV什么项目，参加上创国创是个比较好的选择，可以接触真实场景，这个东西老师很看重，就是你的东西能不能实际落地。总之，有技术含量的项目，并且你能让老师信服这个项目非常有技术含量而且你很懂，就很好了。现在的好的项目非常多，网上一搜就能搜很多。</p><p>还有一个比较冷门的方向可能有用，就是自学一些国外的课程，比如CS224N，CS231N等等知名的公开课，然后完成课后习题，这种公开课很有名，懂的都懂（比如搞NLP的没有不知道CS224N的），这种如果老师刚好知道，那就非常好了，就算不知道，你学过这些课程也远胜过本科的课程，因为这些课程质量非常高，能让你对那门课掌握地非常扎实。这些东西是可以写到简历上的。</p><p>关于专业课复习的话，我个人觉得没啥用（也有可能是我被问到的专业课我基本上，平时扎扎实实把该学的学好，老师问的也就那么多，不会专门挑刺，都是问一些常见的问题，甚至我觉得背八股文会更有效（？）至少我专业课回答的时候基本上都能答得出来，比如计算机网络的拥塞机制，数据库的范式，数据结构中的排序，操作系统的调页机制，编译原理的栈式存储之类。这些是针对408来说的。至于要走人工智能方向，机器学习好好学好是非常重要的，我听说有人在lamda某强导面试的时候手推SVM，然后被当场录取。机器学习涉及的数学比较多，SVM更是重中之重，可以说SVM是老师面试的利器，弄懂了也是装逼的利器。范围的话基本上应该是西瓜书的前十章。深度学习方向也还是要对一些基本功掌握地非常好，比如卷积操作、残差、RNN、LSTM等等，这些奠基性的工作搞懂差不多就够了，更新更高的东西老师也未必懂。总而言之，懂得多不如懂得深，你要是能把卷积是如何加速实现并行化的东西说清楚，老师听了也大受震撼，总而言之，有一点让老师留下深刻印象，你就赢了。至于如何引诱（不是）老师问你卷积并行化，很简单，你自我介绍的时候对这个多说两句就行，或者在简历上写相关的项目，你对某个东西多说了两句，老师自然会问这个。</p><p>最后就是心态了，倒也不是让你盲目相信最后一定会有很好的结局，很多人最后其实还是灰心丧气的。只是我觉得应该要想清楚，自己能接受的底线在哪，有了保底，就放心地冲更好的地方。底线思维吧。另外不要斤斤计较于一时一地的得失，比如这个机会错过了，不要懊恼，也不用焦虑，因为机会真的挺多的。哪怕到928都有人一把梭了冲上了浙大，何况之前呢？还有就是，当看到别人可能有很好的去处的时候可能真的很需要调整心态，此时内心必然会受到干扰，但是一定要认准自己的目标去努力，不要一时上头。比如我几个同学报名了港中文，面试也通过了，只要找到导师就能够去了，那个时候我还一个offer都没有，但最后他们也还都是没去港中文。还有一个py去了中科大的超强导师，所有人都以为他要走上学术巅峰了，但是最后他还是跑路了，找了羊导。所以事情还没有尘埃落定之前，真的不好下决定或者判断。再比如我923之前还灰心丧气，觉得自己只能去南大了，结果最后还是迎来了复旦。</p><p>我算是幸运的了，所以我才愈加想要把这段经历写下来，一方面给学弟学妹们作为经验和参考，另外一方面也是希望能够焚毁过去不自信的、焦虑的自己，让过去的自己飘散殆尽。</p>]]></content>
    
    
    
    <tags>
      
      <tag>保研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++ Concurrency in Action - SECOND EDITION》笔记</title>
    <link href="/2022/09/17/%E3%80%8AC-Concurrency-in-Action-SECOND-EDITION%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/17/%E3%80%8AC-Concurrency-in-Action-SECOND-EDITION%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-你好，C-的并发世界"><a href="#第一章-你好，C-的并发世界" class="headerlink" title="第一章 你好，C++的并发世界"></a>第一章 你好，C++的并发世界</h1><p>进程并发的优点：</p><ul><li>依赖于操作系统提供的通信手段，可以有效地保护进程不被其他进程访问和修改，操作系统提供了保护操作和更高级别的通信机制。</li><li>可以实现不同主机之间的并发（网络通信）</li></ul><p>进程并发的缺点：</p><ul><li>进程占用资源更多，启动更慢，通信手段复杂或者低效。</li><li>C++没有提供对多进程的支持，依赖操作系统，不方便跨平台</li></ul><p>线程并发的优点：</p><ul><li>内存共享，方便地进行通信</li><li>资源消耗小，启动更快</li><li>c++支持，所以可以编写跨平台代码</li></ul><p>线程并发的缺点：</p><ul><li>线程的共享管理更复杂，需要良好的维护</li><li>无法跨主机</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(background_task())</span></span>;<br></code></pre></td></tr></table></figure><p>注意这个语法可能会被解析成为函数声明，因此可以用my_thread{backgroud_task())}等。被称为最令人头痛的语法解析</p><p>注意一旦声明了一个线程，就必须要在thread被销毁之前决定是join还是detach。否则的话当thread被销毁的时候会调用terminal 杀死<strong>进程</strong>。注意杀死的不是什么别的东西，杀死的是进程本身。所以主线程和子线程都死了！</p><p>而且注意到一个很奇怪的事实就是，如果main函数退出的话，所有线程也被杀死了。看起来main函数退出是进程退出，资源回收（<strong>进程是资源分配的单位，线程也是资源</strong>），所以所有的线程也要退出。</p><p>join 加入，等到线程完成之后再退出。要注意如果主线程异常的话，join会被跳过。</p><p>下面的一些代码展示如何避免这个问题，就是捕捉异常之后要及时地决定线程join或者detach。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">func</span>; <span class="hljs-comment">// 定义在清单2.1中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> some_local_state=<span class="hljs-number">0</span>;<br>  <span class="hljs-function">func <span class="hljs-title">my_func</span><span class="hljs-params">(some_local_state)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(my_func)</span></span>;<br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    <span class="hljs-built_in">do_something_in_current_thread</span>();<br>  &#125;<br>  <span class="hljs-built_in">catch</span>(...)<br>  &#123;<br>    t.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">throw</span>;<br>  &#125;<br>  t.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据异常之后会自动进行析构函数销毁变量，可以重定义thread，让他在析构的时候首先join。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_guard</span><br>&#123;<br>  std::thread&amp; t;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(std::thread&amp; t_)</span>:</span><br><span class="hljs-function">    t(t_)</span><br><span class="hljs-function">  &#123;</span>&#125;<br>  ~<span class="hljs-built_in">thread_guard</span>()<br>  &#123;<br>    <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>()) <span class="hljs-comment">// 1</span><br>    &#123;<br>      t.<span class="hljs-built_in">join</span>();      <span class="hljs-comment">// 2</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">thread_guard</span>(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;   <span class="hljs-comment">// 3 禁止拷贝或者赋值，是很危险的</span><br>  thread_guard&amp; <span class="hljs-keyword">operator</span>=(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">func</span>; <span class="hljs-comment">// 定义在清单2.1中</span><br><br><span class="hljs-built_in">voidf</span>()<br>&#123;<br>  <span class="hljs-type">int</span> some_local_state=<span class="hljs-number">0</span>;<br>  <span class="hljs-function">func <span class="hljs-title">my_func</span><span class="hljs-params">(some_local_state)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(my_func)</span></span>;<br>  <span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<br>  <span class="hljs-built_in">do_something_in_current_thread</span>();<br>&#125;    <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>detach，分离，一个thread对象调用detach，表示把线程和这个对象分离开，主要是让线程在后台运行。thread被销毁不会影响到他了。注意线程如果引用了临时变量，那么当主线程销毁的时候，该临时变量也可能变得未定义了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">func</span><br>&#123;<br>  <span class="hljs-type">int</span>&amp; i;<br>  <span class="hljs-built_in">func</span>(<span class="hljs-type">int</span>&amp; i_) : <span class="hljs-built_in">i</span>(i_) &#123;&#125;<br>  <span class="hljs-built_in">voidoperator</span>()()<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j=<span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">1000000</span> ; ++j)<br>    &#123;<br>      <span class="hljs-built_in">do_something</span>(i);           <span class="hljs-comment">// 1 潜在访问隐患：悬空引用</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oops</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> some_local_state=<span class="hljs-number">0</span>;<br>  <span class="hljs-function">func <span class="hljs-title">my_func</span><span class="hljs-params">(some_local_state)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(my_func)</span></span>;<br>  my_thread.<span class="hljs-built_in">detach</span>();          <span class="hljs-comment">// 2 不等待线程结束</span><br>&#125;                              <span class="hljs-comment">// 3 新线程可能还在运行</span><br></code></pre></td></tr></table></figure><p>注意看上面这段代码，some_local_state是局部变量，并且直接被my_func使用。当采用detach策略，那么当oops运行完毕的时候，这个变量就会销毁，从而my_func访问了未定义变量。</p><p>【引用的底层实现机制，为什么std::ref()能够提供引用，为什么thread传参需要复制而非引用（可能是无视函数的需求）】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_lengthy_work</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>X my_x;<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>注意看这段文字的初始化方法，第一个参数实际上不是对象的函数，而是类的函数，而第二个参数提供了对象的起始地址，这个方法应该等价于t(my_x.do_lengthy_work))</p><p>线程可以移动，但不能复制，所以同一时间线程只能和一个thread关联，但可以在不同thread之间移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_other_function</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(some_function)</span></span>;            <span class="hljs-comment">// 1</span><br>std::thread t2=std::<span class="hljs-built_in">move</span>(t1);            <span class="hljs-comment">// 2</span><br>t1=std::<span class="hljs-built_in">thread</span>(some_other_function);    <span class="hljs-comment">// 3</span><br>std::thread t3;                            <span class="hljs-comment">// 4</span><br>t3=std::<span class="hljs-built_in">move</span>(t2);                        <span class="hljs-comment">// 5</span><br>t1=std::<span class="hljs-built_in">move</span>(t3);                        <span class="hljs-comment">// 6 赋值操作将使程序崩溃</span><br></code></pre></td></tr></table></figure><p>看上面这段例子，t2初始化的对象是t1，t1作为thread可移动但不能复制。所以如果直接用&#x3D;则是复制操作会崩溃。而3位置是可以的，因为右边是临时对象，移动操作将会隐式的调用。就是移动赋值。</p><p>t3可以直接赋值，但是t1不行，因为t1有线程，所以直接调用terminal终止了进程。不能通过赋值的方式丢弃进程，只能detach，或者join等待线程完成，然后t1才能空下来，这个时候就可以赋值了。</p><p><code>【std::thread</code>对象的容器，如果这个容器是移动敏感的(比如，标准中的 <code>std::vector&lt;&gt;</code>)，那么移动操作同样适用于这些容器。】</p><p>标识符是std::thread::id类型，注意不同于int，尽管cout可以输出int。可以拷贝和对比，因为可以复用。</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>当其中一个成员函数返回的是保护数据的指针或引用时，会破坏数据。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。这就需要对接口有相当谨慎的设计，要确保互斥量能锁住数据的访问，并且不留后门。</p><p>接口之间可能存在竞争的关系，所谓接口就是开放给外部访问的数据？</p><p>比如，一个stack，size() empty 的返回结果是没问题的，但是是不可靠的，因为可能存在有其他竞争在其返回后访问stack。</p><p>一些重要的类含义记录：</p><p>lock_guard：这个类就是对某个互斥量的上锁， 同时在该对象被销毁的时候解锁。</p><p>unique_lock：这个类就是lock_guard的加强版，可以加第二个参数，要不要上锁。因为可以调用lock()函数统一上锁。这个函数需要参数都有lock() unlock() try_lock()三个参数。</p><p>shared_ptr：就是对某块堆上的数据进行智能的监控，当引用为0的时候自动销毁。比如说</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br></code></pre></td></tr></table></figure><p>对于这样的一句话，根据下图所示，首先调用new，生成了widget，然后shared_ptr会生成控制块也就是中间的，包括指针，被引用的次数等。</p><img src="/2022/09/17/%E3%80%8AC-Concurrency-in-Action-SECOND-EDITION%E3%80%8B%E7%AC%94%E8%AE%B0/1663417852421.png" class="" width="1663417852421"><p>但是shared_ptrs都是强引用的，那么会有循环引用的问题：</p><img src="/2022/09/17/%E3%80%8AC-Concurrency-in-Action-SECOND-EDITION%E3%80%8B%E7%AC%94%E8%AE%B0/1663418181574.png" class="" width="1663418181574">比如说这个图中，当我退出程序了，那么Sp1和Sp2都被销毁了，这没啥问题，但是问题是他们指向的对象不会被销毁，因为他们互相引用。需要用weak_ptr在节点内部的指针。<p>make_shared：这个是专门用来制作shared_ptr的，但是不同于上文中shared_ptr p &#x3D; new int()，这里会发生两次alloc。通过make_shared可以将其减少为1次。</p><p>比如说make_shared (move(0))这样，会在分配内存的时候，将控制块和数据内容分配在一起。</p><img src="/2022/09/17/%E3%80%8AC-Concurrency-in-Action-SECOND-EDITION%E3%80%8B%E7%AC%94%E8%AE%B0/1663419089589.png" class="" width="1663419089589"><p>所以实质上所谓的shared_ptr不过是个伪指针罢了。make_shared的好处在于，减少一次alloc开销，而这对性能提升是很大的，其次，占的内存更小，因为减少了大小跟踪的分配器开销，还有增强了数据的局部性，这两个块很可能是在同一个页面或者同一缓冲行。但是带来的问题就在于，由于这两个块分配在了一起，所以必须要等到weak_ptr被释放之后，那一整个块才能被释放（因为make_shared生成的是一整个块）。但是如果是两次分配的话，强指针为0的时候，对应的数据块就被释放了，等到弱指针释放之后，控制块被释放。</p><p>wait函数详解</p><p>这个函数支持一个锁和一个函数为参数。首先会调用这个函数，如果是true，那么就继续执行，如果是false，那么会释放前面的锁，注意，这个锁在传入的时候应该是锁上的。释放之后，进入睡眠状态（为什么要释放呢？因为往往是因为没有东西可以消费，所以阻塞在这里，要释放锁让其他线程从事生产）等到notice_one的时候，再唤醒，然后加锁，然后调用函数，重复上述过程。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 详解</title>
    <link href="/2022/09/10/redis-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/09/10/redis-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<ul><li>redis 单线程，但是redis6.0转向了多线程</li><li>对五种数据结构做详细探索</li><li>AOF如何重写？</li><li>socket如何被当做文件</li><li>进程切换如何实现？具体变化过程，包括保存寄存器等</li></ul><h2 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h2><img src="/2022/09/10/redis-%E8%AF%A6%E8%A7%A3/1662781600705.png" class="" width="1662781600705"><p>1、 应用层处理（HTTP，FTP）</p><p>源端应用程序编码要发送的内容，并且将数据传递给下一层，也就是传输层。</p><p>2、 传输层处理（UDP，TCP）</p><p>基于UDP协议或者TCP协议给数据加上不同的首部。一般说来，传输层定义端口，标识应用程序身份，建立起端口对端口的通信。而TCP协议则在UDP协议基础上建立了保证可靠性的连接。采用三次握手建立连接，四次挥手断开连接。</p><p>3、 网络层处理（IP，ARP，路由器）</p><p>在传输层传来的数据基础上加上首部信息，包括IP地址等。</p><p>4、 数据链路层处理</p><p>在网络层处理的基础上加上首部信息，包括mac地址。</p><p>5、 数据链路层接收</p><p>解析数据包，看是否是自己的mac地址，不是则丢弃，否则根据包中的类型将信息转发给网络层的某个模块，例如IP模块，ARP等。</p><p>6、 网络层接收</p><p>收到数据链路层传来的包，解析IP地址，看是否一致，还要考虑是不是路由器，如果是路由器则还需要根据IP地址在路由控制表中进行转发。或者是和主机IP地址匹配，则判断包类型是TCP还是UDP，然后转发给传输层对应处理模块</p><p>7、 传输层接收</p><p>传输层根据端口转发数据到不同应用程序。</p><p>8、 应用程序层接收</p><p>根据协议解码数据等。</p><h3 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h3><p>三次握手：</p><p>由客户端主动向服务端发送数据包建立连接，首先发送SYN同步请求，随机产生一个seq&#x3D;J值。客户端进入SYN_SEND状态。</p><p>然后服务端将ACK和SYN标志都置位，ack&#x3D;J+1，随机产生seq&#x3D;K。服务器进入SYN_RCVD状态。</p><p>最后客户端检查ack是否等于J+1，并且是否置位ACK，如果是，那么发送一个置位ACK，并且ack&#x3D;K+1。客户端进入ESTABLISHED状态，服务器端接受之后也进入ESTABLISHED状态。</p><p>四次挥手：</p><p>在网络通信中，我们基于通信协议例如TCP&#x2F;IP协议进行数据报的发送和接受，然而在网络层层我们只能实现两个主机之间的通信（即以IP地址标识节点），而一个主机可能有多个运行程序，而这个数据报应该是归哪个运行程序管呢？所以就在传输层（也就是TCP，UDP协议）中引入端口，用于标识不同的应用程序，不同的应用程序监听端口，而传输层在解析的时候会将数据压入不同端口的队列之中。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《存在与时间》笔记</title>
    <link href="/2022/09/02/%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%8E%E6%97%B6%E9%97%B4%E3%80%8B/"/>
    <url>/2022/09/02/%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%8E%E6%97%B6%E9%97%B4%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导论-概述存在意义的问题"><a href="#导论-概述存在意义的问题" class="headerlink" title="导论 概述存在意义的问题"></a>导论 概述存在意义的问题</h1><h2 id="第一章-存在问题的必要性、结构和优先地位"><a href="#第一章-存在问题的必要性、结构和优先地位" class="headerlink" title="第一章 存在问题的必要性、结构和优先地位"></a>第一章 存在问题的必要性、结构和优先地位</h2><h3 id="第一节-突出地重提存在问题的必要性"><a href="#第一节-突出地重提存在问题的必要性" class="headerlink" title="第一节 突出地重提存在问题的必要性"></a>第一节 突出地重提存在问题的必要性</h3><p>在古希腊时代，存在问题是作为一个核心的问题被哲学家思考【形而上学：研究存在者作为存在者，所谓研究xx作为xx，就是研究xx的方式】，在柏拉图和亚里士多德的努力下，从现象那里争取到了一些关于存在的知识，虽然是初级和琐碎的。然而这些知识以各种各样的偏离和“润色”一直保持到了黑格尔的“逻辑学”之中。最终形成了教条，那些关于存在更真实的洞见被遗忘和改写了。</p><p>亚里士多德已经注意到了，存在作为一种普遍性，不同于种的普遍性，即共相，树这个共相可以认为是从无数具体的树中抽象而来，然而存在却不是什么东西抽象的结果，存在不是存在者的抽象，存在者不隶属于存在。所以存在是超越者，超越一切存在者，而他所具备的统一性是一种类比的统一性，以与关乎实事的最高属概念的多样性相对照【除了实体外，还有9个范畴，实体与存在是非常相关的，在古希腊语中，这两者是同一个东西的变式，实体（ousia）、存在(qua)】。所以存在的“统一性”并不同于普通的对统一性的理解。在黑格尔那里，存在作为哲学的开端，是“纯粹无规定的直接性”，并且作为其他范畴的开端。但是存在和其他的范畴的根本区别这一点却被抛弃掉了——存在是一种类比的统一性。</p><p>对于存在，人们形成了三个成见：</p><ul><li>存在是最普遍最空洞的概念</li><li>存在不可定义</li><li>存在是自明的概念</li></ul><p>每个人都不断地使用存在概念，并且认为我们也一向已经懂得了他是什么。存在是不言自明的，然而如康德所说，“自明的东西”，而且只有“自明的东西”——“通常理性的隐蔽判断”——应当成为并且应当始终保持为分析工作的突出课题，即哲学家的事业。（然而对自明的东西的阐明又必然地需要另外一些自明的东西？）</p><p>对于第一种成见，存在无疑是最普遍的，但正如前文亚里士多德所认识到的那样，存在具有独特的统一性，存在作为“普遍者”超越一切存在者。然而这种独特的统一性却没有得到阐明，他是类比而来的统一性，究竟和共相所言的统一性有什么样的区别呢？因此存在是最普遍的，但并不因此就是最清楚的概念。</p><p>对于第二种成见，存在不可定义，是由于存在是最高的普遍者，而定义是来自于最近的种加属差，因而没有任何性质（属差）可以被添加到存在上。存在不能够由更高一级的概念定义；但又不能从低级的概念中抽象，存在不是一切存在者的抽象，所以存在不是某种类似存在者的东西。存在的不可定义反而凸显了存在的意义问题，存在有何意义？这样的独特的概念从何而来，为何有存在概念？</p><p>对于第三种成见，存在是日用而不知的概念，在一切关于存在者的关联之中都需要有存在，例如天是蓝色的，我是快活的。天、我、蓝色、快活都存在。并且这些句子我们都毫无疑问地理解，因而我们向来就已经生活在一种对存在的领会之中了。但存在却没有被理解，并且这种对存在的领会也被忽视了。因而存在的意义还隐藏在晦暗之中。【存在的遗忘是书的线索、开端、原因，造成存在的遗忘的原因是可思想的东西自行遮蔽】</p><p>以上对这些成见的考虑同时也使我们明了：存在问题不仅尚无答案，甚至这个问题本身还是晦暗而茫无头绪的。所以重提存在问题就意味着：首先要充分讨论一番这个问题的提法。</p><p>【司各脱学派主张概念与真实的事物本身不同，事物本身由上帝创造，而思想之中的事物概念是对事物本身的一种类比，就真实的事物就像酒家里的酒，而事物的概念则是酒家外面的酒幌子，这个酒幌子指向了酒的存在。存在作为超越者来说，和存在者也有这样的区别。存在者指向了存在，但又只是存在的一个类比。】</p><h3 id="第二节-存在问题的形式结构"><a href="#第二节-存在问题的形式结构" class="headerlink" title="第二节 存在问题的形式结构"></a>第二节 存在问题的形式结构</h3><p>存在的意义问题还有待提出，在提出存在问题之前，我们有必要对这个发问本身做一番透视。首先考虑一切发问都具有的一般结构。</p><p>任何发问都是一种寻求，任何一种寻求都有从它所寻求的东西方面而来的实现引导。发问总是“对…发问”，因而具有问之所问（Gefragtes），也就是发问的对象（在这里我们的问之所问是存在）；而”对…发问“又总是以”就…“的发问，即发问所问及的东西（Befragtes）（在这里存在总是以存在者的方式展现，因此我们只能就存在者来对存在发问）；而问之所问需要得到规定而成为概念，因此发问还需要有结果，即问之何所以问（Erfragtes）（在这里就是存在的意义，这里的意义应该理解成为含义）。</p><p>接下来根据这一发问的一般结构来对存在问题的发问做探讨。</p><p>作为一种寻求，存在问题的发问需要有来自存在方面的事先引导，因此存在的意义已经以某种方式可供我们使用了。明确提问存在的意义，希望获得存在的概念，这些都是从对存在的某种领会中生发出来的。我们虽然不懂得“存在”，但对于 “存在””是“什么 却已经有所领悟了，这种平均的，含混的对存在的领会是毫无疑问的事实。但在开端处我们无法对平均的含混的存在之领会做出阐述，只有借助于存在概念，阐述工作才能获得必要的线索，有哪些方式会可能地或者必然地使存在陷入晦暗和蒙蔽。</p><p>存在意义问题的问之所问是存在，所谓存在就是规定存在者之为存在者的东西。因此存在有别于存在者，存在者的解释可以通过一种“叙述历史”的方式进行，即以另一个更高的存在者来规定存在者，比如用种加属差的方式规定胡杨树，那么树就是那个更高的存在者。但存在不能追溯到另一个存在者，因为凡是讨论存在者必然地已经先行领会了存在了。所以存在作为问之所问要求一种本己的展示方式 ，这种展示方式不同于对存在者的揭示。因此，问之何所以问，即存在的意义，也要求一种本己的概念方式。</p><p>存在总是存在者的存在，因此对存在的发问总是就存在者而发问，为了能够让存在者不加歪曲地给出它的存在性质，就需要一种正确的方式通达它，要求我们赢得并保持一条正确通达存在者的道路。不过，我们可以用存在称谓很多东西，他们的意义是不同的，例如我们所说的东西，所意指的东西，我们对之有所关联行止的东西，他们都存在着，我们应该以哪个存在者作为开始寻求存在的意义？出发点是随意的吗？或者在拟定存在问题的时候，某种确定的存在者具有优先地位？【指的是此在，此在是范本，被作为被问及的东西，但存在的意义不是从这个存在者那里被解读出来的，而是说，此在把存在带入到谐响（回响）的游戏中。存在借由此在而得到认识。】</p><p>为了突出地提出存在问题，并且充分透视这个问题，就要求（1）把审视存在的方式解说清楚，（2）要求把领会意义、从概念上把捉意义的方式解说清楚，（3）把正确选择一种存在者作为范本的可能性准备好，（4）把通达这种存在的天然方式清理出来。审视、领会与形成概念、选择、通达，这些活动都是发问的构成部分，所以他们本身就是能够发问的存在者的存在样式。在这里，问题之引导来源于存在，而问题之问之所问者则是存在意义问题的提问本身，而就所问及的东西就是能够发问的存在者。因此解决这个问题（突出提出存在问题并充分透视）就等于说就这种能发问的存在者，也就是此在，将通达此在的存在的方式清理出来。</p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>海德格尔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
